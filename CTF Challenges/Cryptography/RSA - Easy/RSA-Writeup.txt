#### Baby - Easy

*Can you read my message without the private key?*

```
c: 24795976732186127960014008753803478286219924961358994925564930277505139413283367757656447224830225064133651246343035441112407129772003927463166449052456907513
e: 65537
n: 67037366790941822378007197878613492487588187468048328737227273255156041659689092651657208107757810805499108569166854436320366276808520739379431210884782583791
```
 </br>

The title already reveals that it is about the cryptographic method RSA. Since n only has 158 digits, we have a good chance of finding the two factors, q and p, needed to calculate the private key. [FactorDB](http://factorb.com/index.php) is an online collection of prime numbers which fortunately stores our fully factored n. The private key d can be calculated with ```inverse(e) % (p-1) * (q-1)```. With the private key, the ciphertext c can be decrypted with the equation ```M = pow(C , d) % n```.

***Python script:***
```
from Crypto.Util.number import *

p = 7796601204626807
q = 8598280844627430267706791405975187760390046230909096659417881790296619284204527797467017995321195814866230752519838250409205362581256112387913
n = 67037366790941822378007197878613492487588187468048328737227273255156041659689092651657208107757810805499108569166854436320366276808520739379431210884782583791
c = 24795976732186127960014008753803478286219924961358994925564930277505139413283367757656447224830225064133651246343035441112407129772003927463166449052456907513
e = 65537

d = inverse(e,(p-1)*(q-1))
m = pow(c,d,p*q)
print("Message: ", long_to_bytes(m))
```

The flag is ```nland{ROll1n9_your_Own_r54}```